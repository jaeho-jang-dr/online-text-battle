import sqlite3 from 'sqlite3';
import { Database, open } from 'sqlite';
import path from 'path';

let db: Database<sqlite3.Database, sqlite3.Statement> | null = null;

export async function initializeDatabase(): Promise<Database<sqlite3.Database, sqlite3.Statement>> {
  if (db) {
    return db;
  }

  try {
    const dbPath = process.env.DATABASE_URL || path.join(process.cwd(), 'database.sqlite');
    
    db = await open({
      filename: dbPath,
      driver: sqlite3.Database
    });

    console.log('üóÑÔ∏è  SQLite Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ');

    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î ÏÉùÏÑ±
    await createTables();

    return db;
  } catch (error) {
    console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®:', error);
    throw error;
  }
}

async function createTables(): Promise<void> {
  if (!db) throw new Error('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');

  try {
    // Users ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_login DATETIME,
        is_admin BOOLEAN DEFAULT FALSE,
        is_active BOOLEAN DEFAULT TRUE
      )
    `);

    // Characters ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS characters (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        name VARCHAR(50) NOT NULL,
        level INTEGER DEFAULT 1,
        health INTEGER DEFAULT 100,
        max_health INTEGER DEFAULT 100,
        mana INTEGER DEFAULT 50,
        max_mana INTEGER DEFAULT 50,
        strength INTEGER DEFAULT 10,
        defense INTEGER DEFAULT 8,
        speed INTEGER DEFAULT 10,
        experience INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
      )
    `);

    // Skills ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS skills (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name VARCHAR(50) NOT NULL,
        description TEXT,
        mana_cost INTEGER DEFAULT 0,
        damage INTEGER DEFAULT 0,
        heal_amount INTEGER DEFAULT 0,
        cooldown INTEGER DEFAULT 0,
        skill_type VARCHAR(20) DEFAULT 'attack',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Character_Skills ÌÖåÏù¥Î∏î (Ï∫êÎ¶≠ÌÑ∞Í∞Ä Î≥¥Ïú†Ìïú Ïä§ÌÇ¨)
    await db.exec(`
      CREATE TABLE IF NOT EXISTS character_skills (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        character_id INTEGER NOT NULL,
        skill_id INTEGER NOT NULL,
        level INTEGER DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (character_id) REFERENCES characters (id) ON DELETE CASCADE,
        FOREIGN KEY (skill_id) REFERENCES skills (id) ON DELETE CASCADE,
        UNIQUE(character_id, skill_id)
      )
    `);

    // Battles ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS battles (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        player1_id INTEGER NOT NULL,
        player2_id INTEGER NOT NULL,
        winner_id INTEGER,
        status VARCHAR(20) DEFAULT 'waiting',
        turn_count INTEGER DEFAULT 0,
        current_turn INTEGER DEFAULT 1,
        battle_data TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        finished_at DATETIME,
        FOREIGN KEY (player1_id) REFERENCES characters (id),
        FOREIGN KEY (player2_id) REFERENCES characters (id),
        FOREIGN KEY (winner_id) REFERENCES characters (id)
      )
    `);

    // Battle_Actions ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS battle_actions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        battle_id INTEGER NOT NULL,
        character_id INTEGER NOT NULL,
        action_type VARCHAR(20) NOT NULL,
        skill_id INTEGER,
        target_id INTEGER,
        damage INTEGER DEFAULT 0,
        heal_amount INTEGER DEFAULT 0,
        turn_number INTEGER NOT NULL,
        action_data TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (battle_id) REFERENCES battles (id) ON DELETE CASCADE,
        FOREIGN KEY (character_id) REFERENCES characters (id),
        FOREIGN KEY (skill_id) REFERENCES skills (id),
        FOREIGN KEY (target_id) REFERENCES characters (id)
      )
    `);

    // Rankings ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS rankings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        character_id INTEGER NOT NULL,
        wins INTEGER DEFAULT 0,
        losses INTEGER DEFAULT 0,
        draws INTEGER DEFAULT 0,
        points INTEGER DEFAULT 1000,
        rank INTEGER DEFAULT 0,
        season INTEGER DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (character_id) REFERENCES characters (id) ON DELETE CASCADE
      )
    `);

    // System_Logs ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS system_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        level VARCHAR(10) NOT NULL,
        message TEXT NOT NULL,
        details TEXT,
        user_id INTEGER,
        ip_address VARCHAR(45),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id)
      )
    `);

    // Game_Settings ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS game_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        setting_key VARCHAR(50) UNIQUE NOT NULL,
        setting_value TEXT NOT NULL,
        description TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Ï±ÑÌåÖ Î©îÏãúÏßÄ ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS chat_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        sender_id INTEGER,
        battle_id INTEGER,
        channel_type TEXT NOT NULL DEFAULT 'global',
        recipient_id INTEGER,
        message TEXT NOT NULL,
        is_system BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (sender_id) REFERENCES users(id) ON DELETE SET NULL,
        FOREIGN KEY (battle_id) REFERENCES battles(id) ON DELETE CASCADE,
        FOREIGN KEY (recipient_id) REFERENCES users(id) ON DELETE SET NULL
      )
    `);

    // Î¶¨ÌîåÎ†àÏù¥ ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS replays (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        battle_id INTEGER UNIQUE NOT NULL,
        title TEXT,
        description TEXT,
        replay_data TEXT NOT NULL,
        duration INTEGER NOT NULL,
        winner_id INTEGER,
        player1_id INTEGER NOT NULL,
        player2_id INTEGER NOT NULL,
        total_turns INTEGER NOT NULL,
        view_count INTEGER DEFAULT 0,
        is_featured BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (battle_id) REFERENCES battles(id) ON DELETE CASCADE,
        FOREIGN KEY (winner_id) REFERENCES characters(id) ON DELETE SET NULL,
        FOREIGN KEY (player1_id) REFERENCES characters(id) ON DELETE CASCADE,
        FOREIGN KEY (player2_id) REFERENCES characters(id) ON DELETE CASCADE
      )
    `);

    // Îû≠ÌÇπ ÌûàÏä§ÌÜ†Î¶¨ ÌÖåÏù¥Î∏î
    await db.exec(`
      CREATE TABLE IF NOT EXISTS ranking_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        character_id INTEGER NOT NULL,
        rank INTEGER NOT NULL,
        points INTEGER NOT NULL,
        wins INTEGER NOT NULL,
        losses INTEGER NOT NULL,
        draws INTEGER NOT NULL,
        snapshot_date DATE NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (character_id) REFERENCES characters(id) ON DELETE CASCADE,
        UNIQUE(character_id, snapshot_date)
      )
    `);

    // Ïù∏Îç±Ïä§ ÏÉùÏÑ±
    await createIndexes();

    // Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
    await insertDefaultData();

    console.log('üìã Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î ÏÉùÏÑ± ÏôÑÎ£å');
  } catch (error) {
    console.error('‚ùå ÌÖåÏù¥Î∏î ÏÉùÏÑ± Ïã§Ìå®:', error);
    throw error;
  }
}

async function createIndexes(): Promise<void> {
  if (!db) return;

  try {
    await db.exec(`
      CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
      CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
      CREATE INDEX IF NOT EXISTS idx_characters_user_id ON characters(user_id);
      CREATE INDEX IF NOT EXISTS idx_battles_status ON battles(status);
      CREATE INDEX IF NOT EXISTS idx_battles_players ON battles(player1_id, player2_id);
      CREATE INDEX IF NOT EXISTS idx_battle_actions_battle_id ON battle_actions(battle_id);
      CREATE INDEX IF NOT EXISTS idx_rankings_points ON rankings(points DESC);
      CREATE INDEX IF NOT EXISTS idx_system_logs_level ON system_logs(level);
      CREATE INDEX IF NOT EXISTS idx_system_logs_created_at ON system_logs(created_at);
    `);

    console.log('üîç Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïù∏Îç±Ïä§ ÏÉùÏÑ± ÏôÑÎ£å');
  } catch (error) {
    console.error('‚ùå Ïù∏Îç±Ïä§ ÏÉùÏÑ± Ïã§Ìå®:', error);
  }
}

async function insertDefaultData(): Promise<void> {
  if (!db) return;

  try {
    // Í∏∞Î≥∏ Ïä§ÌÇ¨ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏ Î∞è ÏÇΩÏûÖ
    const skillCount = await db.get('SELECT COUNT(*) as count FROM skills');
    
    if (skillCount.count === 0) {
      await db.exec(`
        INSERT INTO skills (name, description, mana_cost, damage, heal_amount, cooldown, skill_type) VALUES
        ('Í∏∞Î≥∏ Í≥µÍ≤©', 'Í∏∞Î≥∏Ï†ÅÏù∏ Î¨ºÎ¶¨ Í≥µÍ≤©ÏûÖÎãàÎã§.', 0, 15, 0, 0, 'attack'),
        ('Í∞ïÌÉÄ', 'Ï†ÅÏóêÍ≤å Í∞ïÎ†•Ìïú Î¨ºÎ¶¨ Í≥µÍ≤©ÏùÑ Í∞ÄÌï©ÎãàÎã§.', 10, 25, 0, 2, 'attack'),
        ('ÏπòÏú†', 'Ï≤¥Î†•ÏùÑ ÌöåÎ≥µÌï©ÎãàÎã§.', 15, 0, 30, 3, 'heal'),
        ('Î∞©Ïñ¥ ÌÉúÏÑ∏', 'Îã§Ïùå ÌÑ¥ÍπåÏßÄ Î∞õÎäî Îç∞ÎØ∏ÏßÄÎ•º 50% Í∞êÏÜåÏãúÌÇµÎãàÎã§.', 5, 0, 0, 2, 'defense'),
        ('ÌååÏù¥Ïñ¥Î≥º', 'ÎßàÎ≤ï ÌôîÏóºÍµ¨Î•º Î∞úÏÇ¨Ìï©ÎãàÎã§.', 20, 30, 0, 3, 'attack'),
        ('ÏïÑÏù¥Ïä§ Ïä§ÌîºÏñ¥', 'ÏñºÏùå Ï∞ΩÏùÑ Î∞úÏÇ¨ÌïòÏó¨ Ï†ÅÏùÑ Í≥µÍ≤©Ìï©ÎãàÎã§.', 18, 28, 0, 3, 'attack'),
        ('ÎùºÏù¥Ìä∏Îãù Î≥ºÌä∏', 'Î≤àÍ∞úÎ•º ÏÜåÌôòÌïòÏó¨ Ï†ÅÏùÑ Í≥µÍ≤©Ìï©ÎãàÎã§.', 22, 32, 0, 4, 'attack'),
        ('ÌûêÎßÅ Ìè¨ÏÖò', 'Í∞ïÎ†•Ìïú ÏπòÏú† ÎßàÎ≤ïÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.', 25, 0, 50, 4, 'heal'),
        ('Îß§ÏßÅ Ïâ¥Îìú', 'ÎßàÎ≤ï Î∞©Ïñ¥ÎßâÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§.', 12, 0, 0, 3, 'defense'),
        ('Î≤ÑÏÑúÏª§ Î™®Îìú', 'Í≥µÍ≤©Î†•ÏùÑ 2ÌÑ¥Í∞Ñ 50% Ï¶ùÍ∞ÄÏãúÌÇµÎãàÎã§.', 15, 0, 0, 5, 'buff');
      `);
      console.log('‚öîÔ∏è  Í∏∞Î≥∏ Ïä§ÌÇ¨ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ ÏôÑÎ£å');
    }

    // Í∏∞Î≥∏ Í≤åÏûÑ ÏÑ§Ï†ï ÌôïÏù∏ Î∞è ÏÇΩÏûÖ
    const settingCount = await db.get('SELECT COUNT(*) as count FROM game_settings');
    
    if (settingCount.count === 0) {
      await db.exec(`
        INSERT INTO game_settings (setting_key, setting_value, description) VALUES
        ('MAX_HEALTH', '100', 'Ï∫êÎ¶≠ÌÑ∞ ÏµúÎåÄ Ï≤¥Î†•'),
        ('MAX_MANA', '50', 'Ï∫êÎ¶≠ÌÑ∞ ÏµúÎåÄ ÎßàÎÇò'),
        ('BASE_DAMAGE', '15', 'Í∏∞Î≥∏ Í≥µÍ≤© Îç∞ÎØ∏ÏßÄ'),
        ('TURN_TIME_LIMIT', '30000', 'ÌÑ¥ Ï†úÌïú ÏãúÍ∞Ñ (Î∞ÄÎ¶¨Ï¥à)'),
        ('MAX_BATTLE_TIME', '300000', 'ÏµúÎåÄ Î∞∞ÌãÄ ÏãúÍ∞Ñ (Î∞ÄÎ¶¨Ï¥à)'),
        ('STARTING_POINTS', '1000', 'Ïã†Í∑ú Ï∫êÎ¶≠ÌÑ∞ ÏãúÏûë Îû≠ÌÇπ Ï†êÏàò'),
        ('MAINTENANCE_MODE', 'false', 'Ï†êÍ≤Ä Î™®Îìú ÌôúÏÑ±Ìôî Ïó¨Î∂Ä'),
        ('MAX_CONCURRENT_BATTLES', '100', 'ÏµúÎåÄ ÎèôÏãú Î∞∞ÌãÄ Ïàò');
      `);
      console.log('‚öôÔ∏è  Í∏∞Î≥∏ Í≤åÏûÑ ÏÑ§Ï†ï ÏÇΩÏûÖ ÏôÑÎ£å');
    }

  } catch (error) {
    console.error('‚ùå Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ Ïã§Ìå®:', error);
  }
}

export async function getDatabase(): Promise<Database<sqlite3.Database, sqlite3.Statement>> {
  if (!db) {
    throw new Error('Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. initializeDatabase()Î•º Î®ºÏ†Ä Ìò∏Ï∂úÌïòÏÑ∏Ïöî.');
  }
  return db;
}

export async function closeDatabase(): Promise<void> {
  if (db) {
    await db.close();
    db = null;
    console.log('üîí Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¢ÖÎ£å');
  }
}

// Ìä∏ÎûúÏû≠ÏÖò Ìó¨Ìçº Ìï®Ïàò
export async function runTransaction<T>(callback: (db: Database<sqlite3.Database, sqlite3.Statement>) => Promise<T>): Promise<T> {
  const database = await getDatabase();
  
  try {
    await database.exec('BEGIN TRANSACTION');
    const result = await callback(database);
    await database.exec('COMMIT');
    return result;
  } catch (error) {
    await database.exec('ROLLBACK');
    throw error;
  }
}

// Î°úÍ∑∏ Í∏∞Î°ù Ìï®Ïàò
export async function logSystemEvent(level: 'info' | 'warn' | 'error' | 'debug', message: string, details?: any, userId?: number, ipAddress?: string): Promise<void> {
  try {
    const database = await getDatabase();
    await database.run(`
      INSERT INTO system_logs (level, message, details, user_id, ip_address)
      VALUES (?, ?, ?, ?, ?)
    `, [level, message, details ? JSON.stringify(details) : null, userId || null, ipAddress || null]);
  } catch (error) {
    console.error('ÏãúÏä§ÌÖú Î°úÍ∑∏ Í∏∞Î°ù Ïã§Ìå®:', error);
  }
}